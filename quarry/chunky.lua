-- chunky.lua
-- Использование:
--   chunky <depth>
--
-- Асумпции:
-- - Черепаха стоит лицом ОТ сундука, сундук сзади.
-- - Копаем карьер размером 16 (вправо, X) x depth (вниз, Y) x 16 (вперёд, Z).
-- - Начинаем копать на 1 блок ниже стартового уровня.
-- - Топливо:
--     слот 1 = блоки угля (предпочтительно)
--     слоты 2-3 = другое топливо
-- - Черепаха возвращается в старт и скидывает лут в сундук.
-- - Состояние пишется в chunky_state.txt, чтобы продолжить после рестарта.
-- - Автоматически создаёт startup для автозапуска.

local args = { ... }

local STATE_FILE = "chunky_state.txt"

local function printUsage()
  print("Chunky quarry turtle program (chunk 16x16)")
  print()
  print("Usage:")
  print("  chunky <depth>")
  print()
  print("  depth - depth (down, blocks)")
end

local function ensureStartup()
  if fs.exists("startup") then return end
  
  local startupContent = [[
-- startup (auto-generated by chunky.lua)
if fs.exists("chunky_state.txt") then
  print("Auto-resuming chunky...")
  shell.run("chunky")
else
  print("Auto-starting chunky at depth 64")
  shell.run("chunky", "64")
end
]]
  
  local h = fs.open("startup", "w")
  if h then
    h.write(startupContent)
    h.close()
    print("Created startup file for auto-run.")
  end
end

local function saveState(state)
  local h = fs.open(STATE_FILE, "w")
  if not h then return end
  h.write(textutils.serialize(state))
  h.close()
end

local function loadState()
  if not fs.exists(STATE_FILE) then return nil end
  local h = fs.open(STATE_FILE, "r")
  if not h then return nil end
  local data = h.readAll()
  h.close()
  local ok, t = pcall(textutils.unserialize, data)
  if not ok then return nil end
  return t
end

local function clearState()
  if fs.exists(STATE_FILE) then
    fs.delete(STATE_FILE)
  end
end

-- ========== Аргументы / восстановление ==========

local targetX = 16
local targetZ = 16
local targetY

local state = loadState()
if state then
  print("Found saved state, resuming...")
  targetY = state.targetY
else
  ensureStartup() -- Создаём startup при первом запуске
  if #args < 1 then
    printUsage()
    return
  end
  targetY = tonumber(args[1])
  if not targetY or targetY <= 0 then
    print("Invalid depth.")
    printUsage()
    return
  end
  state = {
    targetX = targetX,
    targetY = targetY,
    targetZ = targetZ,
    x = 0, y = 0, z = 0,
    dir = 0,          -- 0=+Z,1=+X,2=-Z,3=-X
    layer = 0,        -- сколько слоёв уже выкопано полностью
    rowZ = 0,         -- текущий Z-ряд в слое
    initDone = false, -- спущены ли уже на первый блок
  }
end

-- ========== Состояние в локальных переменных ==========

local startX, startY, startZ = 0, 0, 0
local x, y, z   = state.x, state.y, state.z
local dir       = state.dir
local layer     = state.layer
local rowZ      = state.rowZ
local initDone  = state.initDone

local TRASH = {
  ["minecraft:cobblestone"] = true,
  ["minecraft:deepslate"]   = true,
  ["minecraft:tuff"]        = true,
  ["minecraft:dirt"]        = true,
  ["minecraft:gravel"]      = true,
}

local function isTrash(detail)
  return detail and TRASH[detail.name]
end

local function refuelFromSlot(slot)
  if turtle.getItemCount(slot) == 0 then return false end
  turtle.select(slot)
  local ok = turtle.refuel(1)
  if not ok then
    turtle.select(1)
    return false
  end
  while turtle.getItemCount(slot) > 0 and turtle.refuel(1) do end
  turtle.select(1)
  return true
end

local function refuelIfNeeded()
  if turtle.getFuelLevel() == "unlimited" then return end
  if turtle.getFuelLevel() > 50 then return end

  if refuelFromSlot(1) then return end
  if refuelFromSlot(2) then return end
  if refuelFromSlot(3) then return end
end

local function saveRuntimeState()
  state.x = x
  state.y = y
  state.z = z
  state.dir = dir
  state.layer = layer
  state.rowZ = rowZ
  state.initDone = initDone
  saveState(state)
end

local function tryForward()
  while true do
    refuelIfNeeded()
    if turtle.forward() then
      if dir == 0 then z = z + 1
      elseif dir == 1 then x = x + 1
      elseif dir == 2 then z = z - 1
      elseif dir == 3 then x = x - 1
      end
      saveRuntimeState()
      return true
    else
      if turtle.detect() then
        turtle.dig()
      else
        turtle.attack()
      end
      sleep(0.2)
    end
  end
end

local function tryUp()
  while true do
    refuelIfNeeded()
    if turtle.up() then
      y = y - 1
      saveRuntimeState()
      return true
    else
      if turtle.detectUp() then
        turtle.digUp()
      else
        turtle.attackUp()
      end
      sleep(0.2)
    end
  end
end

local function tryDown()
  while true do
    refuelIfNeeded()
    if turtle.down() then
      y = y + 1
      saveRuntimeState()
      return true
    else
      if turtle.detectDown() then
        turtle.digDown()
      else
        turtle.attackDown()
      end
      sleep(0.2)
    end
  end
end

local function turnRight()
  turtle.turnRight()
  dir = (dir + 1) % 4
  saveRuntimeState()
end

local function turnLeft()
  turtle.turnLeft()
  dir = (dir + 3) % 4
  saveRuntimeState()
end

local function faceDir(targetDir)
  while dir ~= targetDir do
    turnRight()
  end
end

local function goTo(xTarget, yTarget, zTarget)
  while y < yTarget do
    tryDown()
  end
  while y > yTarget do
    tryUp()
  end

  if xTarget > x then
    faceDir(1)
    while x < xTarget do
      tryForward()
    end
  elseif xTarget < x then
    faceDir(3)
    while x > xTarget do
      tryForward()
    end
  end

  if zTarget > z then
    faceDir(0)
    while z < zTarget do
      tryForward()
    end
  elseif zTarget < z then
    faceDir(2)
    while z > zTarget do
      tryForward()
    end
  end
end

local function trashInventory()
  for slot = 4, 16 do
    local detail = turtle.getItemDetail(slot)
    if detail and isTrash(detail) then
      turtle.select(slot)
      turtle.drop()
    end
  end
  turtle.select(1)
end

local function dropAllToChestBehind()
  faceDir(2) -- -Z
  for slot = 4, 16 do
    if turtle.getItemCount(slot) > 0 then
      turtle.select(slot)
      turtle.drop()
    end
  end
  turtle.select(1)
end

local function returnToBaseAndDump()
  goTo(startX, startY, startZ)
  dropAllToChestBehind()
  saveRuntimeState()
end

local function isInventoryFull()
  for slot = 4, 16 do
    if turtle.getItemCount(slot) == 0 then
      return false
    end
  end
  return true
end

local function checkInventoryAndDumpIfFull()
  trashInventory()
  if isInventoryFull() then
    local curX, curY, curZ, curDir = x, y, z, dir
    returnToBaseAndDump()
    goTo(curX, curY, curZ)
    faceDir(curDir)
  end
end

-- ========== Копание слоя с возобновлением ==========

local function digLayer()
  -- layer уже содержит номер текущего слоя (0..targetY-1)
  for dz = rowZ, targetZ - 1 do
    if dz > rowZ then
      if dz % 2 == 1 then
        faceDir(1)
      else
        faceDir(3)
      end
      if turtle.detect() then turtle.dig() end
      tryForward()
      checkInventoryAndDumpIfFull()
      rowZ = dz
      saveRuntimeState()
    end

    if dz % 2 == 0 then
      faceDir(1)
      while x < targetX - 1 do
        if turtle.detectDown() then turtle.digDown() end
        if turtle.detect() then turtle.dig() end
        tryForward()
        checkInventoryAndDumpIfFull()
      end
      if turtle.detectDown() then turtle.digDown() end
    else
      faceDir(3)
      while x > 0 do
        if turtle.detectDown() then turtle.digDown() end
        if turtle.detect() then turtle.dig() end
        tryForward()
        checkInventoryAndDumpIfFull()
      end
      if turtle.detectDown() then turtle.digDown() end
    end

    rowZ = dz
    saveRuntimeState()
  end
end

local function runQuarry()
  if not initDone then
    tryDown()
    y = 1
    initDone = true
    saveRuntimeState()
  end

  while layer < targetY do
    digLayer()
    layer = layer + 1
    rowZ = 0
    saveRuntimeState()

    if layer < targetY then
      goTo(0, y, 0)
      if turtle.detectDown() then turtle.digDown() end
      tryDown()
    end
  end

  returnToBaseAndDump()
  faceDir(0)
  clearState()
end

print("Starting chunky quarry 16x"..targetY.."x16 ...")
saveRuntimeState()
runQuarry()
print("Chunky quarry complete.")
